---
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r, echo =FALSE, cache=TRUE, results='asis'}
# read mdg_invaded_clean files from google drive folder
library(ggplot2)
```

# INVADED RANGES
# 0. Study periods
## - mdg_invaded_clean


```{r, echo =FALSE, cache=TRUE, results='asis'}
 directory_files_mdg = list.files("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results") 
 directory_files_mdg = directory_files_mdg[(directory_files_mdg |>
   grepl(pattern = "mdg_invaded_clean"))]
```


```{r, echo =FALSE, cache=TRUE, results='asis'}
## 1. periods
file_link_mdg = paste0("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results/", directory_files_mdg[grepl("periods_output", directory_files_mdg)])
periods_mdg = read.csv(file = file_link_mdg)
```

```{r, echo =FALSE, cache=TRUE, results='asis'}
periods_range_mdg = data.frame(Period = 1:ncol(periods_mdg))
for (i in 1:ncol(periods_mdg)) {
  periods_range_mdg$range[i] = paste(min(periods_mdg[, i], na.rm = T), 
                                  max(periods_mdg[ , i], na.rm = T), sep = "-")
}

periods_range_mdg$range = as.factor(periods_range_mdg$range)
```


Occurrence records for the *mdg_invaded_clean* landscape were divided into `r length(periods_mdg)` 10-year periods (`r length(periods_mdg) * 10` years) between `r min(periods_mdg[[1]])` - `r max(periods_mdg[[length(periods_mdg)]])`. These periods provides information on *temporal variations* in the different biases. We use ANOVA and the Tukey multiple comparison tests to test for these variations. The data are also grouped by their *family (taxonomic rank)* which forms the basis of the comparisons

# 1. Taxonomic biases

We use the following measures to assess taxonomic bias:

- differences in the number of species identified between taxonomic groups
- changes in the number of species identified over time (temporal taxonomic bias)
- whether rare species are over-represented in the data 

```{r, echo =FALSE, cache=TRUE, results='asis'}
## 3. assessSpeciesNumber
file_link_mdg = paste0("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results/", directory_files_mdg[grepl("assessSpeciesNumber_output", directory_files_mdg)])
assessSpeciesNumber_mdg = read.csv(file = file_link_mdg)

assessSpeciesNumber_mdg = assessSpeciesNumber_mdg |> 
  merge(periods_range_mdg, by.x = "Period", by.y = "Period") |>
  na.omit() |> dplyr::rename(Taxonomic_Group = group)
```


Figure 1: Taxonomic coverage (Number of species) for mdg_invaded_clean occurrence data
```{r, echo =FALSE, cache=TRUE, results='asis', fig.show='asis'}
library(ggplot2)
assessSpeciesNumber_mdg |>
  dplyr::filter(!is.na(val)) |>
  ggplot(mapping = aes(x = Period, y = val, color = Taxonomic_Group)) +
  geom_point( ) + geom_line() + 
  theme_bw() + labs(y = "Number of species recorded", 
                    title = "Taxonomic coverage (Number of species) by  Family") +
  theme(legend.position = "none")
```


```{r, echo =FALSE, cache=TRUE, results='asis'}
fit_species_mdg = aov(val ~ Taxonomic_Group , data = assessSpeciesNumber_mdg)
summary_fit_species_mdg = fit_species_mdg |> summary()
p.value_mdg = (summary_fit_species_mdg |> unlist() |> t() |> as.data.frame())$`Pr(>F)1` |> round(5)

# tukey test
tukey_species_mdg = TukeyHSD(fit_species_mdg, "Taxonomic_Group")
species_differences_mdg = tukey_species_mdg$Taxonomic_Group[!(tukey_species_mdg$Taxonomic_Group[, "p adj"] > 0.05) , ] |> as.data.frame() |>  
  dplyr::mutate(diff = abs(diff)) |> dplyr::arrange(desc(diff)) |>
  dplyr::rename(`|difference|` = diff)
```

- we identify biases in taxonomic coverage by comparing the number of species identified in one family relative to the number of species in another family.

- There exists variations in the number of species identified between the different families (taxonomic groups) (Anova p-value = `r p.value_mdg` < 0.005). Therefore, there are families that received more species coverage than others.

- Out of the `r assessSpeciesNumber_mdg$Taxonomic_Group |> unique() |> length() |> choose(2)` pairs of families compared, differences were significant in `r species_differences_mdg |> nrow()` pairs. Taxonomic coverage was therefore present in `r (100 * (species_differences_mdg |> nrow()) / (assessSpeciesNumber_mdg$Taxonomic_Group |> unique() |> length() |> choose(2))) |> round(0)`% of the families compared.

- Table 1 gives the results of the multiple comparison test (tukey test) which ranks the differences in the levels of coverage between the `r species_differences_mdg |> nrow()` pairs of families. Families are ranked from ones the highest absolute difference to those with the least absolute difference.

Table 1: Differences in the number of species identified between families
```{r, echo =FALSE, cache=TRUE, results='asis'}
species_differences_mdg |> knitr::kable()
```

## - Temporal biases in Taxonomic coverage

- From figure 1, we observed a positive slope in the number of species identified over time among some of the families. We estimate the slope of the number of species recorded for each family over time and identify families with a significant changes in taxonomic coverage.

- Table 2 below sorts the familes with temporal bias in taxonomic coverage from families with the highest temporal bias to families with the least temporal bias in taxonomic coverage. (this are families with statistically significant slope) 

```{r, echo =FALSE, cache=TRUE, results='asis'}
library(broom)
library(purrr)

taxonomic_coverage_slope_mdg = split.data.frame(assessSpeciesNumber_mdg, assessSpeciesNumber_mdg$Taxonomic_Group)  |>
  purrr::map(~lm(val ~ 1 + Period, data = .x))|>
  purrr::map_df(tidy) |>
  dplyr::filter(term == 'Period') |>
  dplyr::mutate(term = sort(assessSpeciesNumber_mdg$Taxonomic_Group |> unique())) |>
  dplyr::filter(p.value < 0.05 | p.value == 0.05) |>
  dplyr::rename(Taxonomic_group = term) |> dplyr::arrange(desc(estimate))
```

- `r taxonomic_coverage_slope_mdg$Taxonomic_group |> unique() |> length()` out of the `r assessSpeciesNumber_mdg$Taxonomic_Group |> unique() |> length()` families (`r (100 * (taxonomic_coverage_slope_mdg$Taxonomic_group |> unique() |> length()) / (assessSpeciesNumber_mdg$Taxonomic_Group |> unique() |> length())) |> round(0)`%) had a significant temporal bias in taxonomic coverage 

Table 2: Slope estimates of the number of species identified by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis'}
taxonomic_coverage_slope_mdg |> knitr::kable()
```



## - representation of rare species

- Here, we measure the congruence of the number of times species have been recorded and their estimated commonness (i.e range sizes). We obtain the taxonomic bias index as the *R-square* value from regression of the number of records on range sizes (https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.8299). 

- A higher R-square value  indicates that species are sampled in proportion to their range sizes while lower values indicate presence of over-sampled or under-sampled species. This method did not differentiate between over-sampling or under-sampling. *NOTE: here, over-sampling or under-sampling of a family is done "independent" of how other families have been sampled.*

- To differentiate between over-sampling or under-sampling, Barends et al. (2020) (https://koedoe.co.za/index.php/koedoe/article/view/1579/2311) compared the residual values of each family to the range of *mean ± standard deviation* of all residual values. *NOTE: here, over-sampling or under-sampling of a family is done "relative" to how other families have been sampled.*

- Families with residual number of records $> (mean\ +\ standard\ deviation)$ were over-sampled while families with residuals $< (mean\ -\ standard\ deviation)$ were under-sampled

```{r, echo =FALSE, cache=TRUE, results='asis'}
## 4. assessRarityBias
file_link_mdg = paste0("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results/", directory_files_mdg[grepl("assessRarityBias_output", directory_files_mdg)])
assessRarityBias_mdg = read.csv(file = file_link_mdg)

assessRarityBias_mdg = assessRarityBias_mdg |> 
  merge(periods_range_mdg, by.x = "period", by.y = "Period") |>
  dplyr::filter(!is.na(index)) |>
  dplyr::rename(Taxonomic_Group = id)
```

Figure 3(a): Taxonomic bias index (Rare species representation) for mdg_invaded_clean occurrence data
```{r, echo =FALSE, cache=TRUE, results='asis', fig.show='asis'}
assessRarityBias_mdg |>
  ggplot(mapping = aes(x = period, y = index, color = Taxonomic_Group)) +
  geom_point( ) + geom_line() + 
  theme_bw() + labs(y = "Taxonomic bias index", 
                    title = "Taxonomic coverage (Rare species representation)") +
  theme(legend.position = "none")
```


Table 3(a): Summary of the coverage index of rare species by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis'}
rare_coverage_ranges_mdg = assessRarityBias_mdg |>
  dplyr::group_by(Taxonomic_Group)|>
  dplyr::summarise(n_periods = (period |> unique() |> length()),
                   from_period = (period |> unique() |> min()),
                   to_period = (period |> unique() |> max()),
                   mean = mean(index) |> round(2),
                   min = min(index) |> round(2),
                   max = max(index) |> round(2),
                   range = (max - min),
                   sd = sd(index) |> round(2)) |>
  dplyr::arrange(mean, from_period, to_period)

rare_coverage_ranges_mdg |> knitr::kable()
```


- Table 3(a) above gives:
    (i) The earliest and latest period, and the number of periods where species within a family were recorded
    (ii) a summary of the taxonomic bias index for different families across all the periods where species within that family were recorded. 
    
-  The number of periods in which species were recorded varied from `r rare_coverage_ranges_mdg$n_periods |> min()` to `r rare_coverage_ranges_mdg$n_periods |> max()` for different families

- taxonomic coverage indices for a family varied between periods. The range between the period with the highest coverage and the period with the lowest coverage varied between `r rare_coverage_ranges_mdg$range |> min()` and `r rare_coverage_ranges_mdg$range |> max()` for different species

- different families also had different levels of taxonomic coverage. The minimum coverage index for a single 10-year period ranged between `r rare_coverage_ranges_mdg$min |> min()` and `r rare_coverage_ranges_mdg$min |> max()` for different families (a difference of `r (rare_coverage_ranges_mdg$min |> max() - (rare_coverage_ranges_mdg$min |> min()))`). Similarly, the maximum coverage index for a single 10-year period ranged between `r rare_coverage_ranges_mdg$max |> min()` and `r rare_coverage_ranges_mdg$max |> max()` for different families (a difference of `r (rare_coverage_ranges_mdg$max |> max() - (rare_coverage_ranges_mdg$max |> min()))`)

- These imply that there exist some level of over-sampling or under-sampling of species within the different families relative to their ranges.

```{r, echo =FALSE, cache=TRUE, results='asis'}
families_mdg = assessRarityBias_mdg$Taxonomic_Group |> unique()

family_residual_mdg = list()
for (family in families_mdg) {
  resid_fam_mdg = assessRarityBias_mdg |>
    dplyr::filter(Taxonomic_Group == family) |>
    dplyr::select(period, res) 
  
  range_all = c(quantile(assessRarityBias_mdg$res, 0.16),
                quantile(assessRarityBias_mdg$res, 0.84))
  
  family_residual_mdg[[family]] = data.frame(family = family,
                                             period = resid_fam_mdg$period,
                                             mean_residual = resid_fam_mdg$res |> round(2),
                                             conf_lower = rep(round(range_all[1], 2), length(resid_fam_mdg$period)),
                                             conf_upper = rep(round(range_all[2], 2), length(resid_fam_mdg$period)),
                                             undersampled = resid_fam_mdg$res < range_all[1],
                                             oversampled = resid_fam_mdg$res > range_all[2]) |>
    dplyr::filter(undersampled == TRUE | oversampled == TRUE)
    
  
}

family_residual_mdg = family_residual_mdg |> dplyr::bind_rows()
rownames(family_residual_mdg) = NULL
```

- Following Barends et al. (2020), we compare the residual values of each family to the range *(mean ± standard deviation)* of all residual values from the model regressing the number of records on range sizes in order to identify undersampled and oversampled families. 

- Residuals "greater than" the range (mean + standard deviation of all residuals) indicate oversampling while residuals "lower than" the range indicate under-sampling. 

- The range $mean\ ±\ standard\ deviation$ of all the residuals from regressing "the number of times species have been recorded" on "estimated commonness (i.e range sizes)" was [`r range_all`]. 

- Table 3(b) below, identifies the number of occupied cells in which a family of species was either over-sampled or under-sampled relative to other families.

Table 3(b): Identifying Oversampled vs Unsersampled families in mdg_invaded_clean dataset
```{r, echo =FALSE, cache=TRUE, results='asis'}
family_residual_mdg |> knitr::kable()
```


- Figure 3(b) below indicates the rate of over-sampling or under-sampling in cells where each family was recorded in, at different time periods.

Figure 3(b): % of Over-sampled and Under-sampled cells by each family per period
```{r, echo =FALSE, cache=TRUE, results='asis', message=FALSE, warning=FALSE}
# Number of cells occupied by each family in a period

source("~/Desktop/Documents/GitHub/bias assessment/connect_db.R") 

# get xmin, xmax, ymin, ymax grouped by family and year
cells = dbGetQuery(aws_con, paste('SELECT family AS family, year AS year, MIN("decimalLongitude") AS xmin, MAX("decimalLongitude") AS xmax, MIN("decimalLatitude") AS ymin, MAX("decimalLatitude") AS ymax FROM mdg_invaded_clean LEFT JOIN mdg_invaded_clean_backbone_family USING (species) WHERE family IS NOT NULL AND year IS NOT NULL GROUP BY family, year'))

# get number of cells from xmin, xmax, ymin, ymax values
for (i in 1:nrow(cells)) {
  cells$n_cells[i] = length(seq(cells$xmin[i], cells$xmax[i], 0.5)) * length(seq(cells$ymin[i], cells$ymax[i], 0.5))
}

cells = cells |>
  dplyr::select(family, year, n_cells)

# match year to the corresponding
for (i in 1:length(cells$year)) {
  for (j in 1:length(periods_mdg)) {
    if(cells$year[i] %in% periods_mdg[[j]]) {
      cells$period[i] = j
    }
  }
}

# total cells occupied during a period
cells = cells |>
  aggregate(n_cells ~ family + period, FUN = sum) |>
  dplyr::filter(family %in% family_residual_mdg$family) |>
  dplyr::arrange(family, period)

# count oversampled/undersampled cells 
oversampled = family_residual_mdg |>
  aggregate(oversampled ~ family + period, FUN = sum)
undersampled = family_residual_mdg |>
  aggregate(undersampled ~ family + period, FUN = sum)

# merge counts of over or undersampled cells
cells = oversampled |>
  dplyr::full_join(undersampled) |>
  dplyr::left_join(cells) |>
  dplyr::mutate(`% oversampled` = round(100 * oversampled / n_cells, 2),
         `% undersampled` = round(100 * undersampled / n_cells, 2)) |> 
  dplyr::arrange(family)

cells |>
    ggplot(mapping = aes(x = period, y = `% oversampled`, col = family)) +
    geom_line() + geom_point() + theme_bw() +
    ylab("% of over-sampled cells by family") + xlab("Period") +
  ggtitle("% of over-sampled cells by family") +
  theme(legend.position = "none")

cells |>
    ggplot(mapping = aes(x = period, y = `% undersampled`, col = family)) +
    geom_line() + geom_point() + theme_bw() +
    ylab("% of under-sampled cells by family") + xlab("Period") +
  ggtitle("% of under-sampled cells by family") +
  theme(legend.position = "none")

undersampled_rate = cells$`% undersampled` |> max()
oversampled_rate = cells$`% oversampled` |> max()
```

- Less than `r undersampled_rate`% and `r oversampled_rate`% of cells in mdg_invaded_clean were under-sampled and over-sampled during any time period respectively. Table 3(c) below summarises each family's range (occupied cells) and the level of over-sampling or under-sampling for different periods.

Table 3(c): Summary table for occupied, over-sampled and under-sampled cells for families in mdg_invaded_clean dataset
```{r, echo =FALSE, cache=TRUE, results='asis'}
cells |> knitr::kable()
```


Table 4: Slope estimates of the coverage index of rare species by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis'}
library(broom)
library(purrr)

rare_coverage_slope_mdg =  split.data.frame(assessRarityBias_mdg, assessRarityBias_mdg$Taxonomic_Group)|>
  purrr::map(~lm(index ~ 1 + period, data = .x))|>
  purrr::map_df(tidy) |>
  dplyr::filter(term == 'period') |>
  dplyr::mutate(term = sort(assessRarityBias_mdg$Taxonomic_Group |> unique())) |>
  dplyr::filter(p.value < 0.05 | p.value == 0.05) |>
  dplyr::rename(Taxonomic_group = term) |> dplyr::arrange(desc(estimate))

rare_coverage_slope_mdg |> knitr::kable()
```

- We observe from table 4, that coverage of rare species did not change except in `r nrow(rare_coverage_slope_mdg)` taxonomic groups in the mdg_invaded_clean dataset where over-representation or under-representation of some species reduced over time. 


# 2. Spatial Biases

We use the following measures to assess spatial bias:
- check whether the data resemble a random distribution in the geographic space of interest
- check whether a representative portion of the spatial domain of interest has been sampled and whether the same portion of geographic space has been sampled over time.

## - randomness sampling distribution in the geographic space

We assessed whether occurrence records resemble a random distribution within the Madagascar's extent. The method compares the average nearest neighbour distance of the data with the average nearest neighbour distances of simulated random distributions of the same density. The nearest neighbour index is obtained by; dividing the average nearest neighbour distance across the occurrence data points by the average nearest neighbour distance from the random sample. An index $<1$ shows more clustered observations compared to the random sample while an index $>1$ indicates occurrences are more dispersed than the random sample.

```{r, echo =FALSE, cache=TRUE, results='asis'}
## 5. assessSpatialBias
file_link_mdg = paste0("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results/", directory_files_mdg[grepl("assessSpatialBias_output", directory_files_mdg)])
assessSpatialBias_mdg = read.csv(file = file_link_mdg)

assessSpatialBias_mdg = assessSpatialBias_mdg |> 
  merge(periods_range_mdg, by.x = "Period", by.y = "Period") |>
  dplyr::filter(!is.na(mean)) |>
  dplyr::rename(Taxonomic_Group = identifier)
```

Figure 4: Nearest neighbour index for mdg_invaded_clean occurrence data
```{r, echo =FALSE, cache=TRUE, results='asis', fig.show='asis'}
assessSpatialBias_mdg |>
  ggplot(mapping = aes(x = Period, y = mean, color = Taxonomic_Group)) +
  geom_point( ) + geom_line() + 
  theme_bw() + labs(y = "Nearest neighbour index", 
                    title = "Randomness of the Occurrence records grouped by family") +
  theme(legend.position = "none")
```

We note that the "Nearest neighbor index $< 1$" for all taxonomic groups across most of the periods. This implies that spatial observations were over-sampled in some areas compared to others within the spatial range analysed; therefore spatial biases were present.

Table 5: Slope estimates of the nearest neighbour index by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis'}
library(broom)
library(purrr)

spatial_index_slope_mdg = split.data.frame(assessSpatialBias_mdg, assessSpatialBias_mdg$Taxonomic_Group) |>
  purrr::map(~lm(mean ~ 1 + Period, data = .x))|>
  purrr::map_df(tidy) |>
  dplyr::filter(term == 'Period') |>
  dplyr::mutate(term = sort(assessSpatialBias_mdg$Taxonomic_Group |> unique())) |>
  dplyr::filter(p.value < 0.05 | p.value == 0.05) |>
  dplyr::rename(Taxonomic_group = term) |> dplyr::arrange(desc(estimate))

spatial_index_slope_mdg |> knitr::kable()
```

We also note more clustered sampling among `r nrow(spatial_index_slope_mdg)` taxonomic groups over time suggesting an increase in spatial bias within these groups.

We map the occurrence records at a 0.5 resolution grid to visualize the distribution of the different taxonomic group records over time.

Figure 5: Spatial map for mdg_invaded_clean occurrence data
```{r, echo =FALSE, cache=TRUE, results='asis', fig.show='asis'}
library(magick)
## 6. assessSpatialCov
file_link_mdg = paste0("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results/", directory_files_mdg[grepl("assessSpatialCov_output", directory_files_mdg)])
knitr::include_graphics(file_link_mdg)
```


# 3. biases in Sampling intensity 


We use the Sums the number of records in the dataset in each time period to identify temporal variation in sampling intensity. 

Figure 6: sampling intensity by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis', fig.show='asis'}
## 7. assessRecordNumber
file_link_mdg = paste0("~/Desktop/Documents/GitHub/bias assessment/13.  bias assessment results/", directory_files_mdg[grepl("assessRecordNumber_output", directory_files_mdg)])
assessRecordNumber_mdg = read.csv(file = file_link_mdg)

assessRecordNumber_mdg = assessRecordNumber_mdg |> 
  merge(periods_range_mdg, by.x = "Period", by.y = "Period") |>
  dplyr::rename(Taxonomic_Group = group)
```


```{r, echo =FALSE, cache=TRUE, results='asis'}
## plot
library(broom)
library(purrr)

sampling_intensity_slope_mdg = split.data.frame(assessRecordNumber_mdg, assessRecordNumber_mdg$Taxonomic_Group) |>
  purrr::map(~lm(val ~ 1 + Period, data = .x))|>
  purrr::map_df(tidy) |>
  dplyr::filter(term == 'Period') |>
  dplyr::mutate(term = sort(assessRecordNumber_mdg$Taxonomic_Group |> unique())) |>
  dplyr::filter(p.value < 0.05 | p.value == 0.05) |>
  dplyr::rename(Taxonomic_group = term) |> dplyr::arrange(desc(estimate))
```

We observe significant positive slopes indicating an increase in sampling intensity among `r nrow(sampling_intensity_slope_mdg)` out of the `r length(unique(assessRecordNumber_mdg$Taxonomic_Group))` (`r (100 * nrow(sampling_intensity_slope_mdg) / length(unique(assessRecordNumber_mdg$Taxonomic_Group))) |> round(4)`) taxonomic groups in the mdg_invaded_clean occurrence dataset, as shown in table 6 below.

Table 7 identifies the taxonomic groups whose sampling intensity differ significantly from each other.


Table 6: Slope estimates of the sampling intensity by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis'}
sampling_intensity_slope_mdg |> knitr::kable()
```

Table 7: Differences sampling intensity by taxonomic group
```{r, echo =FALSE, cache=TRUE, results='asis'}
fit_records_mdg = aov(val ~ Taxonomic_Group , data = assessRecordNumber_mdg)
summary_fit_records_mdg = fit_records_mdg |> summary()
p.value_mdg = (summary_fit_records_mdg |> unlist() |> t() |> as.data.frame())$`Pr(>F)1` |> round(5)

# tukey test
tukey_species_mdg = TukeyHSD(fit_records_mdg, "Taxonomic_Group")
records_differences_mdg = tukey_species_mdg$Taxonomic_Group[!(tukey_species_mdg$Taxonomic_Group[, "p adj"] > 0.05) , ] |> as.data.frame() |>  dplyr::arrange(desc(diff))

records_differences_mdg |> knitr::kable()
```

## correlation between sampling intensity and number of species

```{r, echo=FALSE, cache=TRUE}
correlation_mdg = cor.test(assessSpeciesNumber_mdg$val, assessRecordNumber_mdg$val)
```

We observe a positive correlation $cor =$ `r correlation_mdg$estimate` (p.value_mdg = `r correlation_mdg$p.value`). This indicates presence of sampling bias (higher sampling intensities) towards families with more species.
